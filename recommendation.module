<?php

/*
 * Implement hook_menu
 */

function recommendation_menu() {
    $items['recommendation/updatesimilarity'] = array(
        'title' => 'Update table similarity',
        'description' => 'Update table similarity i.e. the similarity score of all records',
        'page callback' => 'update_similarity',
        'access callback' => TRUE,
        'type' => MENU_CALLBACK
    );

    return $items;
}

/*
 * Implemens hook_block_info
 */

function recommendation_block_info() {
    $blocks['recommendation'] = array(
        'info' => t('Recommendation'),
        'region' => 'sidebar_first',
        'status' => TRUE
    );
    return $blocks;
}

/*
 * Implements hook_block_configure
 */

function recommendation_block_configure($delta = '') {
    
}

/*
 * Implements hook_block_save
 */

function recommendation_block_save($delta, $edit = array()) {
    
}

/*
 * Implements hook_block_view
 */

function recommendation_block_view($delta = '') {
    global $user;
    $blocks['subject'] = 'Recommendation';
    $contents = '<ul>';
    $recommendation_title = array();
    $recommendation_score = array();
    //get all users who have similarity relationship with $user
    $similarity = db_query('SELECT * FROM {similarity} WHERE uid1=:uid1', array(':uid1' => $user->uid));
    foreach ($similarity as $row) {
        //for each similar user get all the node he has voted
        $similar_entity = db_query('SELECT v.entity_id, v.value, n.title from {votingapi_vote}AS v LEFT JOIN {node} AS n ON n.nid=v.entity_id WHERE v.uid=:uid', array(':uid' => $row->uid2));
        foreach ($similar_entity as $entity) {
            $recommendation_title[$entity->entity_id] = $entity->title;
            if (isset($recommendation_score[$entity->entity_id])) {
                $recommendation_score[$entity->entity_id] = $recommendation_score[$entity->entity_id] + $entity->value * $row->score;
            } else {
                $recommendation_score[$entity->entity_id] = $entity->value * $row->score;
            }
        }
    }
    //decide the number of nodes to be recommended
    $num_recom = variable_get('recommend_number');
    $num_recom = count($recommendation_score) > $num_recom ? $num_recom : count($recommendation_score);
    if (!empty($recommendation_score)) {
        //sort the recommendation according to score DESC
        asort($recommendation_score);
        $recommendation_score = array_reverse($recommendation_score, TRUE);
        //slice $recommendation_score array and get $num_recom highest recommendation
        $recommendation_score = array_slice($recommendation_score, 0, $num_recom);
        foreach ($recommendation_score as $entity_id => $score) {
            $contents .= '<li><a href="node/' . $entity_id . '" target="_blank">' . $recommendation_title[$entity_id] . "</a>:score " . $score . '</li>';
        }
    }
    $contents .= '</ul>';
    $blocks['content'] = $contents;
    return $blocks;
}

/*
 * Implements hook_cron
 * 
 * Automatically update table similarity
 */

function recommendation_cron() {
    update_similarity();
}

/*
 * Update table similarity
 */

function update_similarity() {
    /* similarity of user i and j are defined as 
     * s_{ij}=\sum{v_{ia}v_{ja}}/(W_iW_j)
     *  where v_{ia} is the vote value of user i to paper a.
     */
    //if there is less than one user in table users except anonymous user(uid = 0),exit the function
    $results = db_query("SELECT uid FROM {users} WHERE uid > :uid0", array("uid0" => 0));
    if (count($results) <= 1) {
        exit;
    }

    //calculate the vote value of uid to entity_id
    $sql = 'SELECT uid, entity_id, value FROM {votingapi_vote} WHERE entity_type ="node" and uid != 0 GROUP BY uid, entity_id ORDER BY uid';
    $weights = db_query($sql);

    //if there is less than one voting record, exit the function
    if (count($weights) <= 1) {
        exit;
    }

    //calculate the the W_i for each user i
    //$w[i] : the W_i of user i
    $w = array();
    $lastuser = $weights[0]["uid"];
    $sum = 0;
    foreach ($weights as $weight) {
        $uid = $weight["uid"];
        if ($uid != 0) {
            if ($uid != $lastuser) {
                $w[$lastuser] = $sum;
                $lastuser = $uid;
                $sum = $weight["w"] * $weight["w"];
            } else {
                $sum += $weight["w"] * $weight["w"];
            }
        }
    }
    $w[$lastuser] = $sum;
    $num = count($w);
    $i = 1;

    // calculate the similarity and update it
    foreach ($w as $user1 => $wp1) {
        $j = 0;
        foreach ($w as $user2 => $wp2) {
            $wc = 0;
            foreach ($weights as $weight) {
                if ($weight["uid"] == $user1) {
                    $pid = $weight["entity_id"];
                    foreach ($weights as $weight2) {
                        if ($weight2["uid"] == $user2 && $weight2["entity_id"] == $pid) {
                            $wc += $weight["w"] * $weight2["w"];
                        }
                    }
                }
            }
            if ($j >= $i) {
                //update similarity
                $s = $wc / pow($wp1 * $wp2, 0.5);
                //$row1 = $similar->fetchRow($similar->select()->where('(user1 = "' . $user1 . '" and user2 = "' . $user2 . '" )'));
                //$row2 = $similar->fetchRow($similar->select()->where('(user1 = "' . $user2 . '" and user2 = "' . $user1 . '" )'));
                $row1 = db_query("select * from {similarity} where user1=:user1 and user2=:user2", array(":user1" => $user1, ":user2" => $user2));
                $row2 = db_query("select * from {similarity} where user1=:user2 and user2=:user1", array(":user1" => $user1, ":user2" => $user2));
                if ($row1) {
                    db_update("similarity")
                            ->fields(array(
                                "score" => $s,
                                "update_time" => REQUEST_TIME
                            ))
                            ->condition("uid1", $user1)
                            ->condition("uid2", $user2)
                            ->execute();
                } else {
                    db_insert("similarity")
                            ->fields(array(
                                "uid1" => $user1,
                                "uid2" => $user2,
                                "score" => $s,
                                "update_time" => REQUEST_TIME
                            ))
                            ->execute();
                }
                if ($row2) {
                    db_update("similarity")
                            ->fields(array(
                                "score" => $s,
                                "update_time" => REQUEST_TIME
                            ))
                            ->condition("uid1", $user2)
                            ->condition("uid2", $user1)
                            ->execute();
                } else {
                    db_insert("similarity")
                            ->fields(array(
                                "uid1" => $user2,
                                "uid2" => $user1,
                                "score" => $s,
                                "update_time" => REQUEST_TIME
                            ))
                            ->execute();
                }
            }
            $j++;
        }
        $i++;
    }
}

?>
